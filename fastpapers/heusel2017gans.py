# AUTOGENERATED! DO NOT EDIT! File to edit: 02_heusel2017gans.ipynb (unless otherwise specified).

__all__ = ['Identity', 'Inception', 'FIDMetric']

# Cell
from scipy import linalg
import torch
from fastprogress.fastprogress import master_bar, progress_bar
from fastai.data.external import untar_data
from fastai.data.transforms import get_image_files
from fastai.data import *
from fastai.basics import *
from fastai.vision.data import *
from fastai.vision.core import *
from fastcore.all import *
from fastai.vision.augment import *
from fastai.vision.gan import *
from .core import *

# Cell
class Identity(nn.Module):
    '''An identity layer useful to shortcircuit the last layers of the inception network.'''
    def __init__(self): super(Identity, self).__init__()
    def forward(self, x): return x

# Cell
class Inception(nn.Module):
    def __init__(self):
        super().__init__()
        model = torch.hub.load('pytorch/vision:v0.6.0', 'inception_v3', pretrained=True)
        model.eval();
        model.fc = Identity()
        model.dropout = Identity()
        self.model = model
    def __call__(self, x):
        x = Resize(299)(x)
        with torch.no_grad():
            logits = self.model(x)
        return nn.Softmax(dim=1)(logits)

# Cell
class FIDMetric(Metric):
    def __init__(self, model, dl):
        if dl.device.type == 'cuda':
            self.func = model.cuda()
        total = []
        for b in progress_bar(dl):
            if isinstance(b, tuple):
                if len(b)==2:
                    b = b[1]
            total.append(self.func(b))
        total = torch.cat(total).cpu()
        self.dist_norm = total.mean(axis=0).pow(2).sum().sqrt()
        total = total / self.dist_norm
        self.dist_mean = total.mean(axis=0)
        self.dist_cov = (total-self.dist_mean).T@(total-self.dist_mean)/total.shape[0]
    def reset(self): self.total, self.count = [], 0
    def accumulate(self, learn):
        if learn.model.gen_mode:
            self.total.append(learn.to_detach(self.func(learn.pred[1])))
            self.count += 1

    @property
    def value(self):
        if self.count == 0: return None
        total = torch.cat(self.total).cpu()/self.dist_norm
        self.sample_mean = total.mean(axis=0).cpu()
        self.sample_cov = (total-self.sample_mean).T@(total-self.sample_mean)/total.shape[0]
        self.sample_cov = self.sample_cov.cpu()
        mean_loss = nn.MSELoss(reduction='sum')(self.sample_mean, self.dist_mean)
        cov_sqrt = linalg.sqrtm(self.sample_cov@self.dist_cov)
        if np.iscomplexobj(cov_sqrt):
            if not np.allclose(np.diagonal(cov_sqrt).imag, 0, atol=1e-3):
                m = np.max(np.abs(cov_sqrt.imag))
                raise ValueError("Imaginary component {}".format(m))
            cov_sqrt = cov_sqrt.real
        tcov1 = np.trace(self.sample_cov)
        tcov2 = np.trace(self.dist_cov)
        tcov_sqrt = np.trace(cov_sqrt)
        cov_loss = tcov1+tcov2-2*tcov_sqrt#np.trace(cov_sum - 2 * cov_sqrt)
        return mean_loss + cov_loss